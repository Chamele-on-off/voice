#!/usr/bin/env python3
"""
ZINDAKI TTS SERVICE - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –∞–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ Silero TTS API
"""
import os
import sys
import torch
import torchaudio
import tempfile
import time
import shutil
from datetime import datetime
from flask import Flask, request, jsonify, send_file, render_template
from flask_cors import CORS
from pydantic import BaseModel, ValidationError
import redis
from rq import Queue
from rq.job import Job
import threading
import atexit

# ========== –ù–ê–°–¢–†–û–ô–ö–ê –û–ö–†–£–ñ–ï–ù–ò–Ø ==========
os.environ['TORCH_HOME'] = '/app/cache'
os.environ['HF_HOME'] = '/app/cache'
os.environ['XDG_CACHE_HOME'] = '/app/cache'

# –°–æ–∑–¥–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
os.makedirs('/app/cache/torch/hub', exist_ok=True)
os.makedirs('/app/temp_audio', exist_ok=True)

# ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø REDIS ==========
redis_conn = redis.Redis(
    host=os.getenv('REDIS_HOST', 'tts-redis'),
    port=int(os.getenv('REDIS_PORT', 6379)),
    db=1,
    socket_connect_timeout=10,
    socket_timeout=30,
    retry_on_timeout=True
)

# –û—á–µ—Ä–µ–¥—å –∑–∞–¥–∞—á
queue = Queue(connection=redis_conn, default_timeout=600)

# ========== –ù–ê–°–¢–†–û–ô–ö–ê FLASK ==========
app = Flask(__name__, template_folder='templates')
CORS(app, resources={r"/*": {"origins": "*"}})

# ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ==========
tts_models = {}
startup_time = datetime.now()

# ========== –ü–û–î–î–ï–†–ñ–ò–í–ê–ï–ú–´–ï –ì–û–õ–û–°–ê (–ë–ï–ó –°–£–§–§–ò–ö–°–û–í) ==========
SUPPORTED_VOICES = {
    'ru': ['baya', 'aidar', 'kseniya', 'irina', 'natasha', 'ruslan'],
    'en': ['en_1']
}

# ========== –ú–û–î–ï–õ–¨ –ó–ê–ü–†–û–°–ê ==========
class TTSRequest(BaseModel):
    """–í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥—è—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤"""
    text: str
    language: str = 'ru'
    speaker: str = 'baya'
    sample_rate: int = 16000

    class Config:
        extra = 'forbid'

# ========== –§–£–ù–ö–¶–ò–Ø –ó–ê–ì–†–£–ó–ö–ò –ú–û–î–ï–õ–ò ==========
def load_tts_model(language='ru', user_speaker='baya'):
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç –º–æ–¥–µ–ª—å Silero TTS –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞–º–∏ –º–æ–¥–µ–ª–∏.
    """
    model_key = f"{language}_{user_speaker}"
    if model_key not in tts_models:
        print(f"üì• –ó–∞–≥—Ä—É–∂–∞—é –º–æ–¥–µ–ª—å TTS: {language}/{user_speaker}")
        torch.hub.set_dir('/app/cache/torch/hub')

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –ª–∏ –≥–æ–ª–æ—Å
        if language not in SUPPORTED_VOICES or user_speaker not in SUPPORTED_VOICES[language]:
            print(f"‚ö†Ô∏è –ì–æ–ª–æ—Å '{user_speaker}' –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –¥–ª—è —è–∑—ã–∫–∞ '{language}'. –ò—Å–ø–æ–ª—å–∑—É–µ–º 'baya' –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.")
            user_speaker = 'baya'

        try:
            # –ó–∞–≥—Ä—É–∂–∞–µ–º –º–æ–¥–µ–ª—å RU v4 (—Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è —Ä—É—Å—Å–∫–∏—Ö –≥–æ–ª–æ—Å–æ–≤)
            if language == 'ru':
                result = torch.hub.load(
                    repo_or_dir='snakers4/silero-models',
                    model='silero_tts',
                    language='ru',
                    speaker='v4_ru',  # ‚Üê –∫–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
                    force_reload=False,
                    trust_repo=True,
                    verbose=False
                )
            else:
                raise NotImplementedError("Only Russian is configured properly")

            print(f"‚úÖ –ú–æ–¥–µ–ª—å v4_ru –∑–∞–≥—Ä—É–∂–µ–Ω–∞ ({len(result)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤)")
            model, symbols, sample_rate, example_text, apply_tts_func = result

            tts_models[model_key] = {
                'model': model,
                'symbols': symbols,
                'sample_rate': sample_rate,
                'example_text': example_text,
                'apply_tts': apply_tts_func,
                'device': torch.device('cpu'),
                'loaded_at': datetime.now().isoformat()
            }

            model.to(torch.device('cpu'))
            print(f"   Sample rate: {sample_rate} Hz")
            print(f"   –ü—Ä–∏–º–µ—Ä —Ç–µ–∫—Å—Ç–∞: {example_text[:50]}...")

        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏: {e}")
            import traceback
            traceback.print_exc()
            raise

    return tts_models[model_key]

# ========== –§–£–ù–ö–¶–ò–Ø –ì–ï–ù–ï–†–ê–¶–ò–ò –ê–£–î–ò–û ==========
def generate_audio(text, language, speaker, sample_rate):
    """
    –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ –∏–∑ —Ç–µ–∫—Å—Ç–∞.
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ .wav —Ñ–∞–π–ª—É.
    """
    try:
        start_time = time.time()
        print(f"\nüéµ –ù–∞—á–∏–Ω–∞—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∞—É–¥–∏–æ")
        print(f"   –Ø–∑—ã–∫: {language}, –ì–æ–ª–æ—Å: {speaker}")
        print(f"   –¢–µ–∫—Å—Ç: '{text[:100]}{'...' if len(text) > 100 else ''}'")
        print(f"   –î–ª–∏–Ω–∞: {len(text)} —Å–∏–º–≤–æ–ª–æ–≤")

        model_info = load_tts_model(language, speaker)
        model = model_info['model']
        symbols = model_info['symbols']
        target_sample_rate = model_info['sample_rate']
        apply_tts_func = model_info['apply_tts']
        device = model_info['device']

        print(f"   üîä –ò—Å–ø–æ–ª—å–∑—É—é –≥–æ–ª–æ—Å: {speaker}")
        print(f"   üéöÔ∏è  –ß–∞—Å—Ç–æ—Ç–∞: {target_sample_rate} Hz")

        # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å —è–≤–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º speakers
        audio_result = apply_tts_func(
            texts=[text],
            model=model,
            sample_rate=target_sample_rate,
            symbols=symbols,
            device=device,
            speakers=[speaker]  # ‚Üê –í–ê–ñ–ù–û: —É–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∫—Ç–æ—Ä–∞ –∑–¥–µ—Å—å
        )

        # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        if isinstance(audio_result, list):
            if len(audio_result) == 0:
                raise ValueError("apply_tts –≤–µ—Ä–Ω—É–ª –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫")
            audio = audio_result[0]
        else:
            audio = audio_result

        if not hasattr(audio, 'shape'):
            raise ValueError(f"–ê—É–¥–∏–æ –Ω–µ –∏–º–µ–µ—Ç –∞—Ç—Ä–∏–±—É—Ç–∞ shape. –¢–∏–ø: {type(audio)}")

        print(f"   üìê –ò—Å—Ö–æ–¥–Ω—ã–π shape –∞—É–¥–∏–æ: {audio.shape}")

        # –ü—Ä–∏–≤–æ–¥–∏–º –∫ (–∫–∞–Ω–∞–ª—ã, –≤—Ä–µ–º—è)
        if audio.ndim == 1:
            audio = audio.unsqueeze(0) if hasattr(audio, 'unsqueeze') else audio.reshape(1, -1)
        elif audio.ndim == 2:
            if audio.shape[0] != 1 and audio.shape[1] == 1:
                audio = audio.T
        else:
            raise ValueError(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –∞—É–¥–∏–æ: {audio.ndim}")

        print(f"   üìê –§–∏–Ω–∞–ª—å–Ω—ã–π shape –∞—É–¥–∏–æ: {audio.shape}")

        # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ
        temp_dir = '/app/temp_audio'
        os.makedirs(temp_dir, exist_ok=True)
        temp_file = tempfile.NamedTemporaryFile(suffix='.wav', delete=False, dir=temp_dir)

        torchaudio.save(temp_file.name, audio, target_sample_rate, format='wav')

        generation_time = time.time() - start_time
        audio_duration = audio.shape[-1] / target_sample_rate
        print(f"‚úÖ –ê—É–¥–∏–æ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ!")
        print(f"   ‚è±Ô∏è  –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {generation_time:.2f} —Å–µ–∫—É–Ω–¥")
        print(f"   üïí –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞—É–¥–∏–æ: {audio_duration:.2f} —Å–µ–∫—É–Ω–¥")
        print(f"   üìÅ –§–∞–π–ª: {temp_file.name}")
        print(f"   üìä –†–∞–∑–º–µ—Ä: {os.path.getsize(temp_file.name) / 1024:.1f} KB")

        return temp_file.name

    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—É–¥–∏–æ: {str(e)}")
        import traceback
        traceback.print_exc()
        raise

# ========== API –ú–ê–†–®–†–£–¢–´ ==========
@app.route('/')
def index():
    try:
        return render_template('index.html')
    except Exception as e:
        print(f"‚ö†Ô∏è –®–∞–±–ª–æ–Ω index.html –Ω–µ –Ω–∞–π–¥–µ–Ω: {e}")
        return jsonify({
            'service': 'Zindaki TTS Service',
            'version': '1.0',
            'status': 'running',
            'endpoints': {
                '/': 'GET - –≥–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞',
                '/api/tts': 'POST - –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ',
                '/api/health': 'GET - –ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è',
                '/api/voices': 'GET - —Å–ø–∏—Å–æ–∫ –≥–æ–ª–æ—Å–æ–≤',
                '/api/test': 'GET - —Ç–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å',
                '/api/debug': 'GET - –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è',
                '/api/status/<job_id>': 'GET - —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏'
            },
            'note': '–î–æ–±–∞–≤—å—Ç–µ —Ñ–∞–π–ª templates/index.html –¥–ª—è –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞'
        })

@app.route('/api/tts', methods=['POST'])
def tts_request():
    try:
        data = request.get_json()
        if not data:
            return jsonify({'error': 'No JSON data provided'}), 400
        req = TTSRequest(**data)

        if len(req.text) == 0:
            return jsonify({'error': 'Text cannot be empty'}), 400
        if len(req.text) > 5000:
            return jsonify({
                'error': f'Text too long ({len(req.text)} chars). Max is 5000.'
            }), 400

        print(f"\nüì® –ü–æ–ª—É—á–µ–Ω TTS –∑–∞–ø—Ä–æ—Å:")
        print(f"   üåê –Ø–∑—ã–∫: {req.language}")
        print(f"   üó£Ô∏è  –ì–æ–ª–æ—Å: {req.speaker}")
        print(f"   üìù –î–ª–∏–Ω–∞ —Ç–µ–∫—Å—Ç–∞: {len(req.text)} —Å–∏–º–≤–æ–ª–æ–≤")

        job = queue.enqueue(
            generate_audio,
            args=(req.text, req.language, req.speaker, req.sample_rate),
            job_timeout=300,
            result_ttl=3600,
            failure_ttl=1800
        )

        return jsonify({
            'job_id': job.get_id(),
            'status': 'queued',
            'message': '–ó–∞–¥–∞—á–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å –æ–±—Ä–∞–±–æ—Ç–∫–∏',
            'estimated_time': '5-30 —Å–µ–∫—É–Ω–¥',
            'models_loaded': list(tts_models.keys()),
            'timestamp': datetime.now().isoformat()
        }), 202

    except ValidationError as e:
        return jsonify({
            'error': 'Invalid request data',
            'details': e.errors()
        }), 400
    except Exception as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –≤ tts_request: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/status/<job_id>', methods=['GET'])
def get_job_status(job_id):
    try:
        job = Job.fetch(job_id, connection=redis_conn)
        if job.is_finished:
            result = job.result
            if not result or not os.path.exists(result):
                return jsonify({'error': 'No audio file generated'}), 500

            response = send_file(
                result,
                mimetype='audio/wav',
                as_attachment=True,
                download_name=f'tts_{job_id}.wav'
            )

            @response.call_on_close
            def cleanup():
                try:
                    if os.path.exists(result):
                        os.remove(result)
                        print(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª: {result}")
                except Exception as e:
                    print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Ñ–∞–π–ª–∞: {e}")
            return response

        elif job.is_failed:
            error_msg = str(job.exc_info) if job.exc_info else 'Unknown error'
            return jsonify({
                'error': 'Job failed',
                'details': error_msg,
                'status': 'failed'
            }), 500
        else:
            return jsonify({
                'status': job.get_status(),
                'position': job.get_position() if hasattr(job, 'get_position') else 'unknown',
                'models_loaded': list(tts_models.keys()),
                'timestamp': datetime.now().isoformat()
            }), 200
    except Exception as e:
        return jsonify({'error': f'Job not found: {str(e)}'}), 404

@app.route('/api/health', methods=['GET'])
def health_check():
    try:
        redis_conn.ping()
        if not tts_models:
            try:
                load_tts_model('ru', 'baya')
            except Exception as e:
                print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å –ø—Ä–∏ health check: {e}")
        return jsonify({
            'status': 'healthy',
            'service': 'zindaki-tts-service',
            'redis': 'connected',
            'models_loaded': list(tts_models.keys()),
            'models_count': len(tts_models),
            'torch_version': torch.__version__,
            'torch_available': torch.cuda.is_available(),
            'python_version': sys.version.split()[0],
            'uptime': str(datetime.now() - startup_time),
            'cache_dir': os.environ.get('TORCH_HOME'),
            'timestamp': datetime.now().isoformat()
        }), 200
    except Exception as e:
        return jsonify({
            'status': 'unhealthy',
            'error': str(e),
            'models_loaded': list(tts_models.keys()),
            'timestamp': datetime.now().isoformat()
        }), 500

@app.route('/api/voices', methods=['GET'])
def get_available_voices():
    voices_info = {
        'ru': [
            {'id': 'baya', 'name': '–ë–∞–π—è', 'gender': 'female', 'description': '–ß–∏—Å—Ç—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å'},
            {'id': 'kseniya', 'name': '–ö—Å–µ–Ω–∏—è', 'gender': 'female', 'description': '–ú—è–≥–∫–∏–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å'},
            {'id': 'aidar', 'name': '–ê–π–¥–∞—Ä', 'gender': 'male', 'description': '–ú—É–∂—Å–∫–æ–π –≥–æ–ª–æ—Å'},
            {'id': 'irina', 'name': '–ò—Ä–∏–Ω–∞', 'gender': 'female', 'description': '–í—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω—ã–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å'},
            {'id': 'natasha', 'name': '–ù–∞—Ç–∞—à–∞', 'gender': 'female', 'description': '–ú–æ–ª–æ–¥–æ–π –∂–µ–Ω—Å–∫–∏–π –≥–æ–ª–æ—Å'},
            {'id': 'ruslan', 'name': '–†—É—Å–ª–∞–Ω', 'gender': 'male', 'description': '–ì–ª—É–±–æ–∫–∏–π –º—É–∂—Å–∫–æ–π –≥–æ–ª–æ—Å'}
        ],
        'en': [
            {'id': 'en_1', 'name': 'English Female', 'gender': 'female', 'description': 'English female voice'}
        ]
    }

    loaded_voices = {}
    for lang in voices_info:
        loaded_voices[lang] = [
            voice for voice in voices_info[lang]
            if f"{lang}_{voice['id']}" in tts_models
        ]

    return jsonify({
        'all_voices': voices_info,
        'loaded_voices': loaded_voices,
        'total_loaded': len(tts_models),
        'timestamp': datetime.now().isoformat()
    })

@app.route('/api/test', methods=['GET'])
def test_endpoint():
    try:
        model_info = load_tts_model('ru', 'baya')
        test_text = "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ TTS —Å–µ—Ä–≤–∏—Å–∞."
        print(f"üß™ –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å: {test_text}")

        audio_result = model_info['apply_tts'](
            texts=[test_text],
            model=model_info['model'],
            sample_rate=model_info['sample_rate'],
            symbols=model_info['symbols'],
            device=model_info['device'],
            speakers=['baya']
        )

        if isinstance(audio_result, list):
            audio = audio_result[0]
            result_type = f"list[{len(audio_result)}]"
        else:
            audio = audio_result
            result_type = str(type(audio_result))

        return jsonify({
            'success': True,
            'message': 'TTS —Å–µ—Ä–≤–∏—Å —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ',
            'result_type': result_type,
            'audio_shape': str(audio.shape) if hasattr(audio, 'shape') else 'no shape',
            'sample_rate': model_info['sample_rate'],
            'model_loaded': True,
            'models_in_cache': list(tts_models.keys()),
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"‚ùå –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –Ω–µ —É–¥–∞–ª—Å—è: {e}")
        return jsonify({
            'success': False,
            'error': str(e),
            'error_details': error_details[:500],
            'models_in_cache': list(tts_models.keys()),
            'timestamp': datetime.now().isoformat()
        }), 500

@app.route('/api/debug', methods=['GET'])
def debug_info():
    templates_dir = '/app/templates'
    template_files = []
    if os.path.exists(templates_dir):
        template_files = os.listdir(templates_dir)

    cache_dir = '/app/cache'
    cache_contents = os.listdir(cache_dir) if os.path.exists(cache_dir) else []

    return jsonify({
        'torch_version': torch.__version__,
        'torchaudio_version': torchaudio.__version__,
        'python_version': sys.version,
        'environment': {k: v for k, v in os.environ.items() if 'TORCH' in k or 'CACHE' in k},
        'cache_dir_contents': cache_contents,
        'templates_dir': templates_dir,
        'template_files': template_files,
        'models_loaded': list(tts_models.keys()),
        'tts_models_structure': {k: list(v.keys()) for k, v in tts_models.items()},
        'timestamp': datetime.now().isoformat()
    })

@app.route('/api/load-model/<language>/<speaker>', methods=['POST'])
def load_model_endpoint(language, speaker):
    try:
        model_key = f"{language}_{speaker}"
        if model_key in tts_models:
            return jsonify({
                'message': 'Model already loaded',
                'model_key': model_key,
                'loaded_at': tts_models[model_key]['loaded_at']
            })
        model_info = load_tts_model(language, speaker)
        return jsonify({
            'message': 'Model loaded successfully',
            'model_key': model_key,
            'sample_rate': model_info['sample_rate'],
            'example_text': model_info['example_text'][:100],
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

# ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
def cleanup_temp_files():
    temp_dir = '/app/temp_audio'
    if os.path.exists(temp_dir):
        try:
            count = 0
            for filename in os.listdir(temp_dir):
                file_path = os.path.join(temp_dir, filename)
                if os.path.isfile(file_path):
                    try:
                        os.remove(file_path)
                        count += 1
                    except:
                        pass
            if count > 0:
                print(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {count} –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤")
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤: {e}")

def periodic_cleanup():
    while True:
        time.sleep(3600)
        cleanup_temp_files()

atexit.register(cleanup_temp_files)

# ========== –ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–ê ==========
if __name__ == '__main__':
    print("\n" + "=" * 70)
    print("üéµ ZINDAKI TTS SERVICE - –°–µ—Ä–≤–∏—Å –æ–∑–≤—É—á–∫–∏ –¥–ª—è –æ–Ω–ª–∞–π–Ω-—à–∫–æ–ª—ã")
    print("=" * 70)
    print(f"üìÖ –î–∞—Ç–∞ –∑–∞–ø—É—Å–∫–∞: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üêç Python –≤–µ—Ä—Å–∏—è: {sys.version.split()[0]}")
    print(f"üî• PyTorch –≤–µ—Ä—Å–∏—è: {torch.__version__}")
    print(f"üéµ TorchAudio –≤–µ—Ä—Å–∏—è: {torchaudio.__version__}")
    print(f"üìÅ –ö—ç—à –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {os.environ.get('TORCH_HOME')}")
    print(f"üìÅ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —à–∞–±–ª–æ–Ω–æ–≤: /app/templates")

    templates_dir = '/app/templates'
    if os.path.exists(templates_dir):
        print(f"‚úÖ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è templates —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        files = os.listdir(templates_dir)
        print(f"   –§–∞–π–ª—ã: {files}")
    else:
        print(f"‚ö†Ô∏è –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è templates –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        os.makedirs(templates_dir, exist_ok=True)
        print(f"   –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è")

    print(f"üîó Redis: {os.getenv('REDIS_HOST', 'tts-redis')}:{os.getenv('REDIS_PORT', 6379)}")
    print("=" * 70)

    cleanup_thread = threading.Thread(target=periodic_cleanup, daemon=True)
    cleanup_thread.start()

    print("\n‚è≥ –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –æ—Å–Ω–æ–≤–Ω–æ–π –º–æ–¥–µ–ª–∏...")
    try:
        load_tts_model('ru', 'baya')
        print(f"‚úÖ –û—Å–Ω–æ–≤–Ω–∞—è –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞: ru_baya")
        print(f"   –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏: {tts_models['ru_baya']['sample_rate']} Hz")
        print(f"   –ü—Ä–∏–º–µ—Ä —Ç–µ–∫—Å—Ç–∞: {tts_models['ru_baya']['example_text'][:50]}...")
    except Exception as e:
        print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –º–æ–¥–µ–ª—å –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ: {e}")
        import traceback
        traceback.print_exc()
        print("   –ú–æ–¥–µ–ª—å –±—É–¥–µ—Ç –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—Ä–æ—Å–µ")

    print("\nüöÄ –ó–∞–ø—É—Å–∫ Flask —Å–µ—Ä–≤–µ—Ä–∞...")
    print(f"üåê –î–æ—Å—Ç—É–ø–µ–Ω –ø–æ –∞–¥—Ä–µ—Å—É: http://0.0.0.0:5000")
    print(f"üìö API –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ: http://0.0.0.0:5000/api/health")
    print("=" * 70)

    app.run(
        host='0.0.0.0',
        port=5000,
        debug=False,
        threaded=True,
        use_reloader=False
    )